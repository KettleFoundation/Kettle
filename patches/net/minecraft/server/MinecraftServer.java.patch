--- ../src-base/minecraft/net/minecraft/server/MinecraftServer.java
+++ ../src-work/minecraft/net/minecraft/server/MinecraftServer.java
@@ -2,6 +2,7 @@
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.ListenableFutureTask;
@@ -17,91 +18,97 @@
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.IOException;
+import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.Proxy;
 import java.net.URLEncoder;
 import java.nio.charset.StandardCharsets;
 import java.security.KeyPair;
 import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.List;
-import java.util.Queue;
-import java.util.Random;
-import java.util.UUID;
+import java.util.*;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
-import java.util.function.Supplier;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+import jline.console.ConsoleReader;
+import joptsimple.OptionSet;
 import net.minecraft.advancements.AdvancementManager;
 import net.minecraft.advancements.FunctionManager;
+import net.minecraft.block.Block;
 import net.minecraft.command.CommandBase;
 import net.minecraft.command.ICommandManager;
 import net.minecraft.command.ICommandSender;
 import net.minecraft.command.ServerCommandManager;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.ICrashReportDetail;
+import net.minecraft.enchantment.Enchantment;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.init.Bootstrap;
+import net.minecraft.item.Item;
 import net.minecraft.network.NetworkSystem;
 import net.minecraft.network.ServerStatusResponse;
 import net.minecraft.network.play.server.SPacketTimeUpdate;
+import net.minecraft.potion.Potion;
 import net.minecraft.profiler.ISnooperInfo;
 import net.minecraft.profiler.Profiler;
 import net.minecraft.profiler.Snooper;
 import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.dedicated.PropertyManager;
 import net.minecraft.server.management.PlayerList;
 import net.minecraft.server.management.PlayerProfileCache;
-import net.minecraft.util.IProgressUpdate;
-import net.minecraft.util.IThreadListener;
-import net.minecraft.util.ITickable;
-import net.minecraft.util.ReportedException;
-import net.minecraft.util.Util;
+import net.minecraft.util.*;
 import net.minecraft.util.datafix.DataFixer;
 import net.minecraft.util.datafix.DataFixesManager;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.text.ITextComponent;
 import net.minecraft.util.text.TextComponentString;
-import net.minecraft.world.EnumDifficulty;
-import net.minecraft.world.GameType;
-import net.minecraft.world.MinecraftException;
-import net.minecraft.world.ServerWorldEventHandler;
-import net.minecraft.world.World;
-import net.minecraft.world.WorldServer;
-import net.minecraft.world.WorldServerDemo;
-import net.minecraft.world.WorldServerMulti;
-import net.minecraft.world.WorldSettings;
-import net.minecraft.world.WorldType;
-import net.minecraft.world.chunk.storage.AnvilSaveConverter;
+import net.minecraft.world.*;
+import net.minecraft.world.chunk.storage.AnvilSaveHandler;
 import net.minecraft.world.storage.ISaveFormat;
 import net.minecraft.world.storage.ISaveHandler;
 import net.minecraft.world.storage.WorldInfo;
+import net.minecraftforge.common.DimensionManager;
+import net.minecraftforge.common.util.EnumHelper;
+import net.minecraftforge.fml.common.FMLCommonHandler;
+import net.minecraftforge.fml.common.registry.EntityRegistry;
+import net.minecraftforge.fml.common.registry.ForgeRegistries;
+import net.minecraftforge.fml.relauncher.ReflectionHelper;
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
+import net.minecraftforge.registries.GameData;
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.World.Environment;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.Main;
+import org.bukkit.craftbukkit.SpigotTimings;
+import org.bukkit.craftbukkit.entity.CraftCustomEntity;
+import org.bukkit.entity.EntityType;
+import org.bukkit.potion.PotionEffectType;
+import org.spigotmc.SlackActivityAccountant;
 
-public abstract class MinecraftServer implements ICommandSender, Runnable, IThreadListener, ISnooperInfo
-{
-    private static final Logger LOGGER = LogManager.getLogger();
+//import jline.console.ConsoleReader;
+
+public abstract class MinecraftServer implements ICommandSender, Runnable, IThreadListener, ISnooperInfo {
+    public static final Logger LOGGER = LogManager.getLogger();
     public static final File USER_CACHE_FILE = new File("usercache.json");
-    private final ISaveFormat anvilConverterForAnvilFile;
+    public ISaveFormat anvilConverterForAnvilFile;
     private final Snooper usageSnooper = new Snooper("server", this, getCurrentTimeMillis());
-    private final File anvilFile;
+    public File anvilFile;
     private final List<ITickable> tickables = Lists.<ITickable>newArrayList();
     public final ICommandManager commandManager;
     public final Profiler profiler = new Profiler();
     private final NetworkSystem networkSystem;
     private final ServerStatusResponse statusResponse = new ServerStatusResponse();
     private final Random random = new Random();
-    private final DataFixer dataFixer;
+    public final DataFixer dataFixer;
     @SideOnly(Side.SERVER)
     private String hostname;
     private int serverPort = -1;
@@ -128,7 +135,6 @@
     private KeyPair serverKeyPair;
     private String serverOwner;
     private String folderName;
-    @SideOnly(Side.CLIENT)
     private String worldName;
     private boolean isDemo;
     private boolean enableBonusChest;
@@ -144,178 +150,264 @@
     private final GameProfileRepository profileRepo;
     private final PlayerProfileCache profileCache;
     private long nanoTimeSinceStatusRefresh;
-    public final Queue < FutureTask<? >> futureTaskQueue = Queues. < FutureTask<? >> newArrayDeque();
+    public final Queue<FutureTask<?>> futureTaskQueue = Queues.<FutureTask<?>>newArrayDeque();
     private Thread serverThread;
     protected long currentTime = getCurrentTimeMillis();
     @SideOnly(Side.CLIENT)
     private boolean worldIconSet;
+    // CraftBukkit start
+    public List<WorldServer> worldServerList = new ArrayList<>();
+    public org.bukkit.craftbukkit.CraftServer server;
+    public OptionSet options;
+    public org.bukkit.command.ConsoleCommandSender console;
+    public org.bukkit.command.RemoteConsoleCommandSender remoteConsole;
+	public ConsoleReader reader;
+    public static int currentTick = (int) (System.currentTimeMillis() / 50);
+    public Thread primaryThread;
+    public Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
+    public int autosavePeriod;
+    // CraftBukkit end
+    // Spigot start
+    public final SlackActivityAccountant slackActivityAccountant = new SlackActivityAccountant();
+    // Spigot end
 
-    public MinecraftServer(File anvilFileIn, Proxy proxyIn, DataFixer dataFixerIn, YggdrasilAuthenticationService authServiceIn, MinecraftSessionService sessionServiceIn, GameProfileRepository profileRepoIn, PlayerProfileCache profileCacheIn)
-    {
+    private static MinecraftServer instance;
+
+    public MinecraftServer(OptionSet options, Proxy proxyIn, DataFixer dataFixerIn,
+            YggdrasilAuthenticationService authServiceIn, MinecraftSessionService sessionServiceIn,
+            GameProfileRepository profileRepoIn, PlayerProfileCache profileCacheIn) {
+        instance = this;
         this.serverProxy = proxyIn;
         this.authService = authServiceIn;
         this.sessionService = sessionServiceIn;
         this.profileRepo = profileRepoIn;
         this.profileCache = profileCacheIn;
-        this.anvilFile = anvilFileIn;
+        // this.anvilFile = anvilFileIn;
         this.networkSystem = new NetworkSystem(this);
         this.commandManager = this.createCommandManager();
-        this.anvilConverterForAnvilFile = new AnvilSaveConverter(anvilFileIn, dataFixerIn);
+        // this.anvilConverterForAnvilFile = new AnvilSaveConverter(anvilFileIn, dataFixerIn); // CraftBukkit - moved to DedicatedServer.init
         this.dataFixer = dataFixerIn;
+        this.options = options;
+        // Try to see if we're actually running in a terminal, disable jline if not
+        if (System.console() == null && System.getProperty("jline.terminal") == null) {
+            System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+            Main.useJline = false;
+        }
+        try {
+            (this.reader = new ConsoleReader(System.in, (OutputStream)System.out)).setExpandEvents(false);
+        }
+        catch (Throwable e) {
+            try {
+                System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+                System.setProperty("user.language", "en");
+                Main.useJline = false;
+                (this.reader = new ConsoleReader(System.in, (OutputStream)System.out)).setExpandEvents(false);
+            }
+            catch (IOException ex) {
+                MinecraftServer.LOGGER.warn((String)null, (Throwable)ex);
+        }
+        }
+        Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.util.ServerShutdownThread(this));
+        this.serverThread = primaryThread = new Thread(net.minecraftforge.fml.common.thread.SidedThreadGroups.SERVER,
+                this, "Server thread"); // Moved from main
     }
 
-    public ServerCommandManager createCommandManager()
-    {
+    public abstract PropertyManager getPropertyManager();
+
+    public ServerCommandManager createCommandManager() {
         return new ServerCommandManager(this);
     }
 
     public abstract boolean init() throws IOException;
 
-    public void convertMapIfNeeded(String worldNameIn)
-    {
-        if (this.getActiveAnvilConverter().isOldMapFormat(worldNameIn))
-        {
+    public void convertMapIfNeeded(String worldNameIn) {
+        if (this.getActiveAnvilConverter().isOldMapFormat(worldNameIn)) {
             LOGGER.info("Converting map!");
             this.setUserMessage("menu.convertingLevel");
-            this.getActiveAnvilConverter().convertMapFormat(worldNameIn, new IProgressUpdate()
-            {
+            this.getActiveAnvilConverter().convertMapFormat(worldNameIn, new IProgressUpdate() {
                 private long startTime = System.currentTimeMillis();
-                public void displaySavingString(String message)
-                {
+
+                public void displaySavingString(String message) {
                 }
-                public void setLoadingProgress(int progress)
-                {
-                    if (System.currentTimeMillis() - this.startTime >= 1000L)
-                    {
+
+                public void setLoadingProgress(int progress) {
+                    if (System.currentTimeMillis() - this.startTime >= 1000L) {
                         this.startTime = System.currentTimeMillis();
-                        MinecraftServer.LOGGER.info("Converting... {}%", (int)progress);
+                        MinecraftServer.LOGGER.info("Converting... {}%", (int) progress);
                     }
                 }
+
                 @SideOnly(Side.CLIENT)
-                public void resetProgressAndMessage(String message)
-                {
+                public void resetProgressAndMessage(String message) {
                 }
+
                 @SideOnly(Side.CLIENT)
-                public void setDoneWorking()
-                {
+                public void setDoneWorking() {
                 }
-                public void displayLoadingString(String message)
-                {
+
+                public void displayLoadingString(String message) {
                 }
             });
         }
     }
 
-    protected synchronized void setUserMessage(String message)
-    {
+    protected synchronized void setUserMessage(String message) {
         this.userMessage = message;
     }
 
     @Nullable
     @SideOnly(Side.CLIENT)
 
-    public synchronized String getUserMessage()
-    {
+    public synchronized String getUserMessage() {
         return this.userMessage;
     }
 
-    public void loadAllWorlds(String saveName, String worldNameIn, long seed, WorldType type, String generatorOptions)
-    {
+    public void loadAllWorlds(String saveName, String worldNameIn, long seed, WorldType type, String generatorOptions) {
+        ServerCommandManager vanillaCommandManager = (ServerCommandManager) this.getCommandManager();
+        vanillaCommandManager.registerVanillaCommands();
         this.convertMapIfNeeded(saveName);
         this.setUserMessage("menu.loadingLevel");
-        ISaveHandler isavehandler = this.anvilConverterForAnvilFile.getSaveLoader(saveName, true);
-        this.setResourcePackFromWorld(this.getFolderName(), isavehandler);
-        WorldInfo worldinfo = isavehandler.loadWorldInfo();
-        WorldSettings worldsettings;
+        this.worlds = new WorldServer[3];
 
-        if (worldinfo == null)
-        {
-            if (this.isDemo())
-            {
-                worldsettings = WorldServerDemo.DEMO_WORLD_SETTINGS;
-            }
-            else
-            {
-                worldsettings = new WorldSettings(seed, this.getGameType(), this.canStructuresSpawn(), this.isHardcore(), type);
-                worldsettings.setGeneratorOptions(generatorOptions);
+        WorldSettings worldsettings = new WorldSettings(seed, this.getGameType(), this.canStructuresSpawn(), this.isHardcore(), type);
+        worldsettings.setGeneratorOptions(generatorOptions);
+        WorldServer world;
 
-                if (this.enableBonusChest)
-                {
-                    worldsettings.enableBonusChest();
+        // WorldServer overWorld = (WorldServer)(isDemo() ? new WorldServerDemo(this, new AnvilSaveHandler(server.getWorldContainer(), worldNameIn , true, this.dataFixer), worldinfo, 0, profiler).init() : new WorldServer(this, new AnvilSaveHandler(server.getWorldContainer(), worldNameIn , true, this.dataFixer), worldinfo, 0, profiler).init());
+        Integer[] dimIds = net.minecraftforge.common.DimensionManager.getStaticDimensionIDs();
+        Arrays.sort(dimIds, new Comparator<Integer>() {
+            @Override
+            public int compare(Integer o1, Integer o2) {
+                // Zero-dimension must always be the first in array!
+                if (o1 == 0) {
+                    return -1;
+                } else {
+                    return Math.max(o1, o2);
                 }
             }
-
-            worldinfo = new WorldInfo(worldsettings, worldNameIn);
-        }
-        else
+        });
+        for (int dim : dimIds)
         {
-            worldinfo.setWorldName(worldNameIn);
-            worldsettings = new WorldSettings(worldinfo);
-        }
-
-        if (false) { //Forge Dead code, reimplemented below
-        for (int i = 0; i < this.worlds.length; ++i)
-        {
-            int j = 0;
-
-            if (i == 1)
-            {
-                j = -1;
+            // World validation
+            if (dim != 0) {
+                if ((dim == -1 && !this.getAllowNether()) || (dim == 1 && !server.getAllowEnd())) {
+                    continue;
+                }
             }
 
-            if (i == 2)
-            {
-                j = 1;
+            String worldType;
+            org.bukkit.World.Environment worldEnvironment = org.bukkit.World.Environment.getEnvironment(dim);
+            if (worldEnvironment == null) {
+                WorldProvider provider = DimensionManager.createProviderFor(dim);
+                worldType = provider.getClass().getSimpleName().toLowerCase();
+                worldType = worldType.replace("worldprovider", "");
+                worldType = worldType.replace("provider", "");
+                worldEnvironment = Environment.getEnvironment(DimensionManager.getProviderType(dim).getId());
+            } else {
+                worldType = worldEnvironment.toString().toLowerCase();
             }
+            String name = (dim == 0) ? saveName : "DIM" + dim;
+            org.bukkit.generator.ChunkGenerator gen = null;
 
-            if (i == 0)
-            {
-                if (this.isDemo())
-                {
-                    this.worlds[i] = (WorldServer)(new WorldServerDemo(this, isavehandler, worldinfo, j, this.profiler)).init();
+            if (dim == 0) {
+                ISaveHandler idatamanager = new AnvilSaveHandler(server.getWorldContainer(), worldNameIn, true, this.dataFixer);
+                WorldInfo worlddata = idatamanager.loadWorldInfo();
+                // Kettle start
+                for (Map.Entry<ResourceLocation, Item> entry : ForgeRegistries.ITEMS.getEntries()) {
+                    ResourceLocation key = entry.getKey();
+                    Item item = entry.getValue();
+                    if(!key.getResourceDomain().equals("minecraft")) {
+                        String materialName = key.toString().toUpperCase().replaceAll("(:|\\s)", "_").replaceAll("\\W", "");
+                        Material material = Material.addMaterial(EnumHelper.addEnum(Material.class, materialName, new Class[]{Integer.TYPE, Integer.TYPE}, new Object[]{Item.getIdFromItem(item), item.getItemStackLimit()}));
+                        if (material != null) {
+                            MinecraftServer.LOGGER.info(String.format("Injected new Forge item material %s with ID %d.", material.name(), material.getId()));
+                        } else {
+                            MinecraftServer.LOGGER.info(String.format("Inject item failure %s with ID %d.", materialName, Item.getIdFromItem(item)));
+                        }
+                    }
                 }
-                else
-                {
-                    this.worlds[i] = (WorldServer)(new WorldServer(this, isavehandler, worldinfo, j, this.profiler)).init();
+                for (Material material : Material.values()) {
+                    if (material.getId() < 256)
+                        Material.addBlockMaterial(material);
                 }
+                for (Map.Entry<ResourceLocation, Block> entry : ForgeRegistries.BLOCKS.getEntries()) {
+                    ResourceLocation key = entry.getKey();
+                    Block block = entry.getValue();
+                    if(!key.getResourceDomain().equals("minecraft")) {
+                        String materialName = key.toString().toUpperCase().replaceAll("(:|\\s)", "_").replaceAll("\\W", "");
+                        Material material = Material.addBlockMaterial(EnumHelper.addEnum(Material.class, materialName, new Class[]{Integer.TYPE}, new Object[]{Block.getIdFromBlock(block)}));
+                        if (material != null) {
+                            MinecraftServer.LOGGER.info(String.format("Injected new Forge block material %s with ID %d.", material.name(), material.getId()));
+                        } else {
+                            MinecraftServer.LOGGER.info(String.format("Inject block failure %s with ID %d.", materialName, Block.getIdFromBlock(block)));
+                        }
+                    }
+                }
+                Map<String, EntityType> NAME_MAP = ReflectionHelper.getPrivateValue(EntityType.class, null, "NAME_MAP");
+                Map<Short, EntityType> ID_MAP = ReflectionHelper.getPrivateValue(EntityType.class, null, "ID_MAP");
 
-                this.worlds[i].initialize(worldsettings);
-            }
-            else
-            {
-                this.worlds[i] = (WorldServer)(new WorldServerMulti(this, isavehandler, j, this.worlds[0], this.profiler)).init();
-            }
+                for (Map.Entry<String, Class<? extends Entity>> entity : EntityRegistry.entityClassMap.entrySet()) {
+                    String entityname = entity.getKey();
+                    String entityType = entityname.replace("-", "_").toUpperCase();
 
-            this.worlds[i].addEventListener(new ServerWorldEventHandler(this, this.worlds[i]));
+                    int typeId = GameData.getEntityRegistry().getID(EntityRegistry.getEntry(entity.getValue()));
+                    EntityType bukkitType = EnumHelper.addEnum(EntityType.class, entityType, new Class[] { String.class, Class.class, Integer.TYPE, Boolean.TYPE }, new Object[] { entityname, CraftCustomEntity.class, typeId, false });
 
-            if (!this.isSinglePlayer())
-            {
-                this.worlds[i].getWorldInfo().setGameType(this.getGameType());
-            }
-        }
-        } //Forge: End dead code
+                    NAME_MAP.put(entityname.toLowerCase(), bukkitType);
+                    ID_MAP.put((short)typeId, bukkitType);
+                }
+                for (Object enchantment : Enchantment.REGISTRY) {
+                    org.bukkit.enchantments.Enchantment.registerEnchantment(new org.bukkit.craftbukkit.enchantments.CraftEnchantment((Enchantment) enchantment));
+                }
+                org.bukkit.enchantments.Enchantment.stopAcceptingRegistrations();
+                for (Object effect : Potion.REGISTRY) {
+                    PotionEffectType.registerPotionEffectType(new org.bukkit.craftbukkit.potion.CraftPotionEffectType((Potion) effect));
+                }
+                PotionEffectType.stopAcceptingRegistrations();
+                server.loadPlugins();
+                server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.STARTUP);
+                // Kettle end
+                if (worlddata == null) {
+                    worlddata = new WorldInfo(worldsettings, worldNameIn);
+                }
+                worlddata.checkName(worldNameIn); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
+                if (this.isDemo()) {
+                    world = (WorldServer) (new WorldServerDemo(this, idatamanager, worlddata, dim, this.profiler)).init();
+                } else {
+                    world = (WorldServer) (new WorldServer(this, idatamanager, worlddata, dim, this.profiler, worldEnvironment, gen)).init();
+                }
 
-        WorldServer overWorld = (WorldServer)(isDemo() ? new WorldServerDemo(this, isavehandler, worldinfo, 0, profiler).init() : new WorldServer(this, isavehandler, worldinfo, 0, profiler).init());
-        overWorld.initialize(worldsettings);
-        for (int dim : net.minecraftforge.common.DimensionManager.getStaticDimensionIDs())
-        {
-            WorldServer world = (dim == 0 ? overWorld : (WorldServer)new WorldServerMulti(this, isavehandler, dim, overWorld, profiler).init());
+                world.initialize(worldsettings);
+                this.server.scoreboardManager = new org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager(this, world.getScoreboard());
+            } else {
+                gen = this.server.getGenerator(name);
+
+                ISaveHandler idatamanager = new AnvilSaveHandler(server.getWorldContainer(), name, true, this.dataFixer);
+                // world =, b0 to dimension, s1 to name, added Environment and gen
+                WorldInfo worlddata = idatamanager.loadWorldInfo();
+                if (worlddata == null) {
+                    worlddata = new WorldInfo(worldsettings, name);
+                }
+                worlddata.checkName(name); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
+                world = (WorldServer) new WorldServerMulti(this, idatamanager, dim, this.worlds[0], this.profiler, worlddata, worldEnvironment, gen).init();
+            }
+            this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldInitEvent(world.getWorld()));
             world.addEventListener(new ServerWorldEventHandler(this, world));
 
             if (!this.isSinglePlayer())
             {
                 world.getWorldInfo().setGameType(this.getGameType());
             }
+            getPlayerList().setPlayerManager(worldServerList.toArray(new WorldServer[worldServerList.size()]));
             net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.WorldEvent.Load(world));
         }
 
-        this.playerList.setPlayerManager(new WorldServer[]{ overWorld });
+        this.playerList.setPlayerManager(this.worlds);
         this.setDifficultyForAllWorlds(this.getDifficulty());
         this.initialWorldChunkLoad();
     }
 
-    public void initialWorldChunkLoad()
-    {
+    public void initialWorldChunkLoad() {
         int i = 16;
         int j = 4;
         int k = 192;
@@ -323,45 +415,52 @@
         int i1 = 0;
         this.setUserMessage("menu.generatingTerrain");
         int j1 = 0;
-        LOGGER.info("Preparing start region for level 0");
-        WorldServer worldserver = net.minecraftforge.common.DimensionManager.getWorld(j1);
-        BlockPos blockpos = worldserver.getSpawnPoint();
-        long k1 = getCurrentTimeMillis();
+        // CraftBukkit start - fire WorldLoadEvent and handle whether or not to keep the spawn in memory
+        for (int m = 0; m < worldServerList.size(); m++) {
+            WorldServer worldserver = this.worldServerList.get(m);
+            MinecraftServer.LOGGER
+                    .info("Preparing start region for level " + m + " (Seed: " + worldserver.getSeed() + ")");
 
-        for (int l1 = -192; l1 <= 192 && this.isServerRunning(); l1 += 16)
-        {
-            for (int i2 = -192; i2 <= 192 && this.isServerRunning(); i2 += 16)
-            {
-                long j2 = getCurrentTimeMillis();
+            if (!worldserver.getWorld().getKeepSpawnInMemory()) {
+                continue;
+            }
 
-                if (j2 - k1 > 1000L)
-                {
-                    this.outputPercentRemaining("Preparing spawn area", i1 * 100 / 625);
-                    k1 = j2;
-                }
+            BlockPos blockposition = worldserver.getSpawnPoint();
+            long jk = getCurrentTimeMillis();
+            i = 0;
 
-                ++i1;
-                worldserver.getChunkProvider().provideChunk(blockpos.getX() + l1 >> 4, blockpos.getZ() + i2 >> 4);
+            for (int l1 = -192; l1 <= 192 && this.isServerRunning(); l1 += 16) {
+                for (int i2 = -192; i2 <= 192 && this.isServerRunning(); i2 += 16) {
+                    long j2 = getCurrentTimeMillis();
+
+                    if (j2 - jk > 1000L) {
+                        this.outputPercentRemaining("Preparing spawn area", i * 100 / 625);
+                        jk = j2;
+                    }
+                    ++i;
+                    worldserver.getChunkProvider().provideChunk(blockposition.getX() + l1 >> 4,
+                            blockposition.getZ() + i2 >> 4);
+                }
             }
         }
 
+        for (WorldServer world : this.worldServerList) {
+            this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldLoadEvent(world.getWorld()));
+        }
+
         this.clearCurrentTask();
     }
 
-    public void setResourcePackFromWorld(String worldNameIn, ISaveHandler saveHandlerIn)
-    {
+    public void setResourcePackFromWorld(String worldNameIn, ISaveHandler saveHandlerIn) {
         File file1 = new File(saveHandlerIn.getWorldDirectory(), "resources.zip");
 
-        if (file1.isFile())
-        {
-            try
-            {
-                this.setResourcePack("level://" + URLEncoder.encode(worldNameIn, StandardCharsets.UTF_8.toString()) + "/" + "resources.zip", "");
+        if (file1.isFile()) {
+            try {
+                this.setResourcePack("level://" + URLEncoder.encode(worldNameIn, StandardCharsets.UTF_8.toString())
+                        + "/" + "resources.zip", "");
+            } catch (UnsupportedEncodingException var5) {
+                LOGGER.warn("Something went wrong url encoding {}", (Object) worldNameIn);
             }
-            catch (UnsupportedEncodingException var5)
-            {
-                LOGGER.warn("Something went wrong url encoding {}", (Object)worldNameIn);
-            }
         }
     }
 
@@ -379,73 +478,79 @@
 
     public abstract boolean shouldBroadcastConsoleToOps();
 
-    protected void outputPercentRemaining(String message, int percent)
-    {
+    protected void outputPercentRemaining(String message, int percent) {
         this.currentTask = message;
         this.percentDone = percent;
         LOGGER.info("{}: {}%", message, Integer.valueOf(percent));
     }
 
-    protected void clearCurrentTask()
-    {
+    protected void clearCurrentTask() {
         this.currentTask = null;
         this.percentDone = 0;
+        this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD);
     }
 
-    public void saveAllWorlds(boolean isSilent)
-    {
-        for (WorldServer worldserver : this.worlds)
-        {
-            if (worldserver != null)
-            {
-                if (!isSilent)
-                {
-                    LOGGER.info("Saving chunks for level '{}'/{}", worldserver.getWorldInfo().getWorldName(), worldserver.provider.getDimensionType().getName());
+    public void saveAllWorlds(boolean isSilent) {
+        for (WorldServer worldserver : this.worldServerList) {
+            if (worldserver != null) {
+                if (!isSilent) {
+                    LOGGER.info("Saving chunks for level '{}'/{}", worldserver.getWorldInfo().getWorldName(),
+                            worldserver.provider.getDimensionType().getName());
                 }
 
-                try
-                {
-                    worldserver.saveAllChunks(true, (IProgressUpdate)null);
-                }
-                catch (MinecraftException minecraftexception)
-                {
+                try {
+                    worldserver.saveAllChunks(true, (IProgressUpdate) null);
+                } catch (MinecraftException minecraftexception) {
                     LOGGER.warn(minecraftexception.getMessage());
                 }
             }
         }
     }
 
-    public void stopServer()
+    private boolean hasStopped = false;
+    private final Object stopLock = new Object();
+
+    public void stopServer() throws MinecraftException
     {
+        org.spigotmc.AsyncCatcher.enabled = false; // Spigot
+        // CraftBukkit start - prevent double stopping on multiple threads
+        synchronized (stopLock) {
+            if (hasStopped)
+                return;
+            hasStopped = true;
+        }
+        // CraftBukkit end
         LOGGER.info("Stopping server");
-
-        if (this.getNetworkSystem() != null)
-        {
+        if (this.server != null) {
+            this.server.disablePlugins();
+        }
+        if (this.getNetworkSystem() != null) {
             this.getNetworkSystem().terminateEndpoints();
         }
 
-        if (this.playerList != null)
-        {
+        if (this.playerList != null) {
             LOGGER.info("Saving players");
             this.playerList.saveAllPlayerData();
             this.playerList.removeAllPlayers();
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException ex) {
+            } // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
         }
 
-        if (this.worlds != null)
-        {
+        if (this.worlds != null) {
             LOGGER.info("Saving worlds");
 
-            for (WorldServer worldserver : this.worlds)
-            {
-                if (worldserver != null)
-                {
+            for (WorldServer worldserver : this.worlds) {
+                if (worldserver != null) {
                     worldserver.disableLevelSaving = false;
                 }
             }
 
             this.saveAllWorlds(false);
 
-            for (WorldServer worldserver1 : this.worlds)
+            // CraftBukkit start - Handled in saveChunks
+            for (WorldServer worldserver1 : this.worldServerList)
             {
                 if (worldserver1 != null)
                 {
@@ -453,159 +558,213 @@
                     worldserver1.flush();
                 }
             }
+            // CraftBukkit end
 
             WorldServer[] tmp = worlds;
-            for (WorldServer world : tmp)
-            {
+            for (WorldServer world : tmp) {
                 net.minecraftforge.common.DimensionManager.setWorld(world.provider.getDimension(), null, this);
             }
         }
 
-        if (this.usageSnooper.isSnooperRunning())
-        {
+        if (this.usageSnooper.isSnooperRunning()) {
             this.usageSnooper.stopSnooper();
         }
 
         CommandBase.setCommandListener(null); // Forge: fix MC-128561
+        // Spigot start
+        if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
+            Object[] p = {"usercache.json"};
+            LOGGER.info("Saving usercache.json");
+            this.profileCache.save();
+        }
+        // Spigot end
     }
 
-    public boolean isServerRunning()
-    {
+    public boolean isServerRunning() {
         return this.serverRunning;
     }
 
-    public void initiateShutdown()
-    {
+    public void initiateShutdown() {
         this.serverRunning = false;
     }
 
+    private static final int TPS = 20;
+    private static final long SEC_IN_NANO = 1000000000;
+    public static final long TICK_TIME = SEC_IN_NANO / TPS;
+    private static final long MAX_CATCHUP_BUFFER = TICK_TIME * TPS * 60L;
+    private static final int SAMPLE_INTERVAL = 20;
+    public final RollingAverage tps1 = new RollingAverage(60);
+    public final RollingAverage tps5 = new RollingAverage(60 * 5);
+    public final RollingAverage tps15 = new RollingAverage(60 * 15);
+    public double[] recentTps = new double[3];
+
+    public static class RollingAverage {
+        private final int size;
+        private long time;
+        private double total;
+        private int index = 0;
+        private final double[] samples;
+        private final long[] times;
+
+              RollingAverage(int size) {
+                  this.size = size;
+                  this.time = size * SEC_IN_NANO;
+                  this.total = TPS * SEC_IN_NANO * size;
+                  this.samples = new double[size];
+                  this.times = new long[size];
+                  for (int i = 0; i < size; i++) {
+                          this.samples[i] = TPS;
+                          this.times[i] = SEC_IN_NANO;
+                      }
+              }
+
+              public void add(double x, long t) {
+                  time -= times[index];
+                  total -= samples[index] * times[index];
+                  samples[index] = x;
+                  times[index] = t;
+                  time += t;
+                  total += x * t;
+                  if (++index == size) {
+                          index = 0;
+                      }
+              }
+
+              public double getAverage() {
+                  return total / time;
+              }
+    }
+
     public void run()
     {
         try
         {
             if (this.init())
             {
-                net.minecraftforge.fml.common.FMLCommonHandler.instance().handleServerStarted();
+                FMLCommonHandler.instance().handleServerStarted();
                 this.currentTime = getCurrentTimeMillis();
                 long i = 0L;
                 this.statusResponse.setServerDescription(new TextComponentString(this.motd));
                 this.statusResponse.setVersion(new ServerStatusResponse.Version("1.12.2", 340));
                 this.applyServerIconToResponse(this.statusResponse);
 
+                // Spigot start
+                Arrays.fill( recentTps, 20 );
+                long start = System.nanoTime(), lastTick = start - TICK_TIME, catchupTime = 0, curTime, wait, tickSection = start;
                 while (this.serverRunning)
                 {
-                    long k = getCurrentTimeMillis();
-                    long j = k - this.currentTime;
-
-                    if (j > 2000L && this.currentTime - this.timeOfLastWarning >= 15000L)
-                    {
-                        LOGGER.warn("Can't keep up! Did the system time change, or is the server overloaded? Running {}ms behind, skipping {} tick(s)", Long.valueOf(j), Long.valueOf(j / 50L));
-                        j = 2000L;
-                        this.timeOfLastWarning = this.currentTime;
+                    curTime = System.nanoTime();
+                    wait = TICK_TIME - (curTime - lastTick);
+                    if (wait > 0) {
+                        if (catchupTime < 2E6) {
+                            wait += Math.abs(catchupTime);
+                        } else if (wait < catchupTime) {
+                            catchupTime -= wait;
+                            wait = 0;
+                    } else {
+                            wait -= catchupTime;
+                            catchupTime = 0;
+                        }
                     }
-
-                    if (j < 0L)
-                    {
-                        LOGGER.warn("Time ran backwards! Did the system time change?");
-                        j = 0L;
+                    if (wait > 0) {
+                        Thread.sleep(wait / 1000000);
+                        curTime = System.nanoTime();
+                        wait = TICK_TIME - (curTime - lastTick);
                     }
 
-                    i += j;
-                    this.currentTime = k;
-
-                    if (this.worlds[0].areAllPlayersAsleep())
+                    catchupTime = Math.min(MAX_CATCHUP_BUFFER, catchupTime - wait);
+                    if ( ++MinecraftServer.currentTick % SAMPLE_INTERVAL == 0 )
                     {
-                        this.tick();
-                        i = 0L;
+                        final long diff = curTime - tickSection;
+                        double currentTps = 1E9 / diff * SAMPLE_INTERVAL;
+                        tps1.add(currentTps, diff);
+                        tps5.add(currentTps, diff);
+                        tps15.add(currentTps, diff);
+                        // Backwards compat with bad plugins
+                        recentTps[0] = tps1.getAverage();
+                        recentTps[1] = tps5.getAverage();
+                        recentTps[2] = tps15.getAverage();
+                        tickSection = curTime;
                     }
-                    else
-                    {
-                        while (i > 50L)
-                        {
-                            i -= 50L;
-                            this.tick();
-                        }
-                    }
+                    lastTick = curTime;
 
-                    Thread.sleep(Math.max(1L, 50L - i));
+                            this.tick();
                     this.serverIsRunning = true;
                 }
-                net.minecraftforge.fml.common.FMLCommonHandler.instance().handleServerStopping();
-                net.minecraftforge.fml.common.FMLCommonHandler.instance().expectServerStopped(); // has to come before finalTick to avoid race conditions
+                // Spigot end
+                FMLCommonHandler.instance().handleServerStopping();
+                FMLCommonHandler.instance().expectServerStopped(); // has to come before finalTick to avoid race conditions
             }
             else
             {
-                net.minecraftforge.fml.common.FMLCommonHandler.instance().expectServerStopped(); // has to come before finalTick to avoid race conditions
-                this.finalTick((CrashReport)null);
+                FMLCommonHandler.instance().expectServerStopped(); // has to come before finalTick to avoid race conditions
+                this.finalTick((CrashReport) null);
             }
-        }
-        catch (net.minecraftforge.fml.common.StartupQuery.AbortedException e)
-        {
+        } catch (net.minecraftforge.fml.common.StartupQuery.AbortedException e) {
             // ignore silently
-            net.minecraftforge.fml.common.FMLCommonHandler.instance().expectServerStopped(); // has to come before finalTick to avoid race conditions
+            FMLCommonHandler.instance().expectServerStopped(); // has to come before finalTick to avoid race conditions
         }
         catch (Throwable throwable1)
         {
             LOGGER.error("Encountered an unexpected exception", throwable1);
             CrashReport crashreport = null;
 
-            if (throwable1 instanceof ReportedException)
-            {
-                crashreport = this.addServerInfoToCrashReport(((ReportedException)throwable1).getCrashReport());
-            }
-            else
-            {
+            if (throwable1 instanceof ReportedException) {
+                crashreport = this.addServerInfoToCrashReport(((ReportedException) throwable1).getCrashReport());
+            } else {
                 crashreport = this.addServerInfoToCrashReport(new CrashReport("Exception in server tick loop", throwable1));
             }
 
-            File file1 = new File(new File(this.getDataDirectory(), "crash-reports"), "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-server.txt");
+            File file1 = new File(new File(this.getDataDirectory(), "crash-reports"),
+                    "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-server.txt");
 
-            if (crashreport.saveToFile(file1))
-            {
-                LOGGER.error("This crash report has been saved to: {}", (Object)file1.getAbsolutePath());
+            if (crashreport.saveToFile(file1)) {
+                LOGGER.error(String.format("This crash report has been saved to: {0}", new Object[] { file1.getAbsolutePath()}));
             }
             else
             {
                 LOGGER.error("We were unable to save this crash report to disk.");
             }
 
-            net.minecraftforge.fml.common.FMLCommonHandler.instance().expectServerStopped(); // has to come before finalTick to avoid race conditions
+            FMLCommonHandler.instance().expectServerStopped(); // has to come before finalTick to avoid race conditions
             this.finalTick(crashreport);
-        }
-        finally
-        {
-            try
-            {
+        } finally {
+            try {
                 this.stopServer();
-            }
-            catch (Throwable throwable)
-            {
+            } catch (Throwable throwable) {
                 LOGGER.error("Exception stopping the server", throwable);
-            }
+                FMLCommonHandler.instance().handleServerStopped();
+                this.serverStopped = true;
+                try {
+                    this.reader.getTerminal().restore();
+                }
+                catch (Exception ex) {}
+                this.systemExitNow();
+                }
             finally
             {
-                net.minecraftforge.fml.common.FMLCommonHandler.instance().handleServerStopped();
+                FMLCommonHandler.instance().handleServerStopped();
                 this.serverStopped = true;
+                try {
+                    this.reader.getTerminal().restore();
+                }
+                catch (Exception ex2) {}
                 this.systemExitNow();
             }
         }
     }
 
-    public void applyServerIconToResponse(ServerStatusResponse response)
-    {
+    public void applyServerIconToResponse(ServerStatusResponse response) {
         File file1 = this.getFile("server-icon.png");
 
-        if (!file1.exists())
-        {
+        if (!file1.exists()) {
             file1 = this.getActiveAnvilConverter().getFile(this.getFolderName(), "icon.png");
         }
 
-        if (file1.isFile())
-        {
+        if (file1.isFile()) {
             ByteBuf bytebuf = Unpooled.buffer();
 
-            try
-            {
+            try {
                 BufferedImage bufferedimage = ImageIO.read(file1);
                 Validate.validState(bufferedimage.getWidth() == 64, "Must be 64 pixels wide");
                 Validate.validState(bufferedimage.getHeight() == 64, "Must be 64 pixels high");
@@ -613,52 +772,42 @@
                 ByteBuf bytebuf1 = Base64.encode(bytebuf);
                 response.setFavicon("data:image/png;base64," + bytebuf1.toString(StandardCharsets.UTF_8));
                 bytebuf1.release(); // Forge: fix MC-122085
-            }
-            catch (Exception exception)
-            {
-                LOGGER.error("Couldn't load server icon", (Throwable)exception);
-            }
-            finally
-            {
+            } catch (Exception exception) {
+                LOGGER.error("Couldn't load server icon", (Throwable) exception);
+            } finally {
                 bytebuf.release();
             }
         }
     }
 
     @SideOnly(Side.CLIENT)
-    public boolean isWorldIconSet()
-    {
+    public boolean isWorldIconSet() {
         this.worldIconSet = this.worldIconSet || this.getWorldIconFile().isFile();
         return this.worldIconSet;
     }
 
     @SideOnly(Side.CLIENT)
-    public File getWorldIconFile()
-    {
+    public File getWorldIconFile() {
         return this.getActiveAnvilConverter().getFile(this.getFolderName(), "icon.png");
     }
 
-    public File getDataDirectory()
-    {
+    public File getDataDirectory() {
         return new File(".");
     }
 
-    public void finalTick(CrashReport report)
-    {
+    public void finalTick(CrashReport report) {
     }
 
-    public void systemExitNow()
-    {
+    public void systemExitNow() {
     }
 
-    public void tick()
-    {
+    public void tick() {
+        SpigotTimings.serverTickTimer.startTiming(); // Spigot
         long i = System.nanoTime();
         net.minecraftforge.fml.common.FMLCommonHandler.instance().onPreServerTick();
         ++this.tickCounter;
 
-        if (this.startProfiling)
-        {
+        if (this.startProfiling) {
             this.startProfiling = false;
             this.profiler.profilingEnabled = true;
             this.profiler.clearProfiling();
@@ -667,16 +816,15 @@
         this.profiler.startSection("root");
         this.updateTimeLightAndEntities();
 
-        if (i - this.nanoTimeSinceStatusRefresh >= 5000000000L)
-        {
+        if (i - this.nanoTimeSinceStatusRefresh >= 5000000000L) {
             this.nanoTimeSinceStatusRefresh = i;
-            this.statusResponse.setPlayers(new ServerStatusResponse.Players(this.getMaxPlayers(), this.getCurrentPlayerCount()));
+            this.statusResponse
+                    .setPlayers(new ServerStatusResponse.Players(this.getMaxPlayers(), this.getCurrentPlayerCount()));
             GameProfile[] agameprofile = new GameProfile[Math.min(this.getCurrentPlayerCount(), 12)];
             int j = MathHelper.getInt(this.random, 0, this.getCurrentPlayerCount() - agameprofile.length);
 
-            for (int k = 0; k < agameprofile.length; ++k)
-            {
-                agameprofile[k] = ((EntityPlayerMP)this.playerList.getPlayers().get(j + k)).getGameProfile();
+            for (int k = 0; k < agameprofile.length; ++k) {
+                agameprofile[k] = ((EntityPlayerMP) this.playerList.getPlayers().get(j + k)).getGameProfile();
             }
 
             Collections.shuffle(Arrays.asList(agameprofile));
@@ -684,12 +832,14 @@
             this.statusResponse.invalidateJson();
         }
 
-        if (this.tickCounter % 900 == 0)
+        if (autosavePeriod > 0 && this.tickCounter % autosavePeriod == 0) // CraftBukkit
         {
+            SpigotTimings.worldSaveTimer.startTiming(); // Spigot
             this.profiler.startSection("save");
             this.playerList.saveAllPlayerData();
             this.saveAllWorlds(true);
             this.profiler.endSection();
+            SpigotTimings.worldSaveTimer.stopTiming(); // Spigot
         }
 
         this.profiler.startSection("tallying");
@@ -697,130 +847,156 @@
         this.profiler.endSection();
         this.profiler.startSection("snooper");
 
-        if (!this.usageSnooper.isSnooperRunning() && this.tickCounter > 100)
-        {
+        if (!this.usageSnooper.isSnooperRunning() && this.tickCounter > 100) {
             this.usageSnooper.startSnooper();
         }
 
-        if (this.tickCounter % 6000 == 0)
-        {
+        if (this.tickCounter % 6000 == 0) {
             this.usageSnooper.addMemoryStatsToSnooper();
         }
 
         this.profiler.endSection();
         this.profiler.endSection();
         net.minecraftforge.fml.common.FMLCommonHandler.instance().onPostServerTick();
+        SpigotTimings.serverTickTimer.stopTiming(); // Spigot
+        org.spigotmc.CustomTimingsHandler.tick(); // Spigot
     }
 
-    public void updateTimeLightAndEntities()
-    {
+    public void updateTimeLightAndEntities() {
+        SpigotTimings.schedulerTimer.startTiming(); // Spigot
+        this.server.getScheduler().mainThreadHeartbeat(this.tickCounter); // CraftBukkit
+        SpigotTimings.schedulerTimer.stopTiming(); // Spigot
         this.profiler.startSection("jobs");
 
-        synchronized (this.futureTaskQueue)
-        {
-            while (!this.futureTaskQueue.isEmpty())
-            {
+        synchronized (this.futureTaskQueue) {
+            while (!this.futureTaskQueue.isEmpty()) {
                 Util.runTask(this.futureTaskQueue.poll(), LOGGER);
             }
         }
 
         this.profiler.endStartSection("levels");
+        // CraftBukkit start
+        // Run tasks that are waiting on processing
+        SpigotTimings.processQueueTimer.startTiming(); // Spigot
+        while (!processQueue.isEmpty()) {
+            processQueue.remove().run();
+        }
+        SpigotTimings.processQueueTimer.stopTiming(); // Spigot
+
+        SpigotTimings.chunkIOTickTimer.startTiming(); // Spigot
+        org.bukkit.craftbukkit.chunkio.ChunkIOExecutor.tick();
+        SpigotTimings.chunkIOTickTimer.stopTiming(); // Spigot
+
+        SpigotTimings.timeUpdateTimer.startTiming(); // Spigot
+        // Send time updates to everyone, it will get the right time from the world the player is in.
+        if (this.tickCounter % 20 == 0) {
+            for (int i = 0; i < this.getPlayerList().getPlayers().size(); ++i) {
+                EntityPlayerMP entityplayer = (EntityPlayerMP) this.getPlayerList().getPlayers().get(i);
+                entityplayer.connection.sendPacket(new SPacketTimeUpdate(entityplayer.world.getTotalWorldTime(),
+                        entityplayer.getPlayerTime(), entityplayer.world.getGameRules().getBoolean("doDaylightCycle"))); // Add support for per player time
+            }
+        }
         net.minecraftforge.common.chunkio.ChunkIOExecutor.tick();
 
-        Integer[] ids = net.minecraftforge.common.DimensionManager.getIDs(this.tickCounter % 200 == 0);
-        for (int x = 0; x < ids.length; x++)
+        for (int x = 0; x < worldServerList.size(); x++)
         {
-            int id = ids[x];
             long i = System.nanoTime();
 
-            if (id == 0 || this.getAllowNether())
+            WorldServer worldserver = worldServerList.get(x);
+            int id = worldserver.dimension;
+
+            this.profiler.func_194340_a(() ->
             {
-                WorldServer worldserver = net.minecraftforge.common.DimensionManager.getWorld(id);
-                this.profiler.func_194340_a(() ->
-                {
-                    return worldserver.getWorldInfo().getWorldName();
-                });
+                return worldserver.getWorldInfo().getWorldName();
+            });
 
-                if (this.tickCounter % 20 == 0)
-                {
-                    this.profiler.startSection("timeSync");
-                    this.playerList.sendPacketToAllPlayersInDimension(new SPacketTimeUpdate(worldserver.getTotalWorldTime(), worldserver.getWorldTime(), worldserver.getGameRules().getBoolean("doDaylightCycle")), worldserver.provider.getDimension());
-                    this.profiler.endSection();
-                }
+            /* Drop global time updates
+            if (this.tickCounter % 20 == 0)
+            {
+                this.profiler.startSection("timeSync");
+                this.playerList.sendPacketToAllPlayersInDimension(new SPacketTimeUpdate(worldserver.getTotalWorldTime(), worldserver.getWorldTime(), worldserver.getGameRules().getBoolean("doDaylightCycle")), worldserver.provider.getDimension());
+                this.profiler.endSection();
+            }
+            */
+            SpigotTimings.timeUpdateTimer.stopTiming(); // Spigot
+            this.profiler.startSection("tick");
+            net.minecraftforge.fml.common.FMLCommonHandler.instance().onPreWorldTick(worldserver);
 
-                this.profiler.startSection("tick");
-                net.minecraftforge.fml.common.FMLCommonHandler.instance().onPreWorldTick(worldserver);
+            try {
+                worldserver.timings.doTick.startTiming(); // Spigot
+                worldserver.tick();
+                worldserver.timings.doTick.stopTiming(); // Spigot
+            } catch (Throwable throwable1) {
+                CrashReport crashreport = CrashReport.makeCrashReport(throwable1, "Exception ticking world");
+                worldserver.addWorldInfoToCrashReport(crashreport);
+                throw new ReportedException(crashreport);
+            }
 
-                try
-                {
-                    worldserver.tick();
-                }
-                catch (Throwable throwable1)
-                {
-                    CrashReport crashreport = CrashReport.makeCrashReport(throwable1, "Exception ticking world");
-                    worldserver.addWorldInfoToCrashReport(crashreport);
-                    throw new ReportedException(crashreport);
-                }
-
-                try
-                {
-                    worldserver.updateEntities();
-                }
-                catch (Throwable throwable)
-                {
-                    CrashReport crashreport1 = CrashReport.makeCrashReport(throwable, "Exception ticking world entities");
-                    worldserver.addWorldInfoToCrashReport(crashreport1);
-                    throw new ReportedException(crashreport1);
-                }
-
-                net.minecraftforge.fml.common.FMLCommonHandler.instance().onPostWorldTick(worldserver);
-                this.profiler.endSection();
-                this.profiler.startSection("tracker");
-                worldserver.getEntityTracker().tick();
-                this.profiler.endSection();
-                this.profiler.endSection();
+            try {
+                worldserver.timings.tickEntities.startTiming(); // Spigot
+                worldserver.updateEntities();
+                worldserver.timings.tickEntities.stopTiming(); // Spigot
+            } catch (Throwable throwable) {
+                CrashReport crashreport1 = CrashReport.makeCrashReport(throwable, "Exception ticking world entities");
+                worldserver.addWorldInfoToCrashReport(crashreport1);
+                throw new ReportedException(crashreport1);
             }
 
-            worldTickTimes.get(id)[this.tickCounter % 100] = System.nanoTime() - i;
+            net.minecraftforge.fml.common.FMLCommonHandler.instance().onPostWorldTick(worldserver);
+            this.profiler.endSection();
+            this.profiler.startSection("tracker");
+            worldserver.timings.tracker.startTiming(); // Spigot
+            worldserver.getEntityTracker().tick();
+            worldserver.timings.tracker.stopTiming(); // Spigot
+            this.profiler.endSection();
+            this.profiler.endSection();
+            // }
+
+            // worldTickTimes.get(id)[this.tickCounter % 100] = System.nanoTime() - i;
         }
 
         this.profiler.endStartSection("dim_unloading");
         net.minecraftforge.common.DimensionManager.unloadWorlds(worldTickTimes);
         this.profiler.endStartSection("connection");
+        SpigotTimings.connectionTimer.startTiming(); // Spigot
         this.getNetworkSystem().networkTick();
+        SpigotTimings.connectionTimer.stopTiming(); // Spigot
         this.profiler.endStartSection("players");
+        SpigotTimings.playerListTimer.startTiming(); // Spigot
         this.playerList.onTick();
+        SpigotTimings.playerListTimer.stopTiming(); // Spigot
         this.profiler.endStartSection("commandFunctions");
+        SpigotTimings.commandFunctionsTimer.startTiming(); // Spigot
         this.getFunctionManager().update();
+        SpigotTimings.commandFunctionsTimer.stopTiming();// Spigot
         this.profiler.endStartSection("tickables");
 
-        for (int k = 0; k < this.tickables.size(); ++k)
-        {
-            ((ITickable)this.tickables.get(k)).update();
+        SpigotTimings.tickablesTimer.startTiming(); // Spigot
+        for (int k = 0; k < this.tickables.size(); ++k) {
+            ((ITickable) this.tickables.get(k)).update();
         }
+        SpigotTimings.tickablesTimer.stopTiming(); // Spigot
 
         this.profiler.endSection();
     }
 
-    public boolean getAllowNether()
-    {
+    public boolean getAllowNether() {
         return true;
     }
 
-    public void startServerThread()
-    {
+    public void startServerThread() {
+        /* CraftBukkit start - prevent abuse
         net.minecraftforge.fml.common.StartupQuery.reset();
         this.serverThread = new Thread(net.minecraftforge.fml.common.thread.SidedThreadGroups.SERVER, this, "Server thread");
         this.serverThread.start();
+        // CraftBukkit end */
     }
 
-    public File getFile(String fileName)
-    {
+    public File getFile(String fileName) {
         return new File(this.getDataDirectory(), fileName);
     }
 
-    public void logWarning(String msg)
-    {
+    public void logWarning(String msg) {
         LOGGER.warn(msg);
     }
 
@@ -835,53 +1011,51 @@
         return ret;
     }
 
-    public String getMinecraftVersion()
-    {
+    public WorldServer getWorldServer(int i) {
+        WorldServer world = getWorld(i);
+        return world != null ? world : worlds[0];
+    }
+
+    public String getMinecraftVersion() {
         return "1.12.2";
     }
 
-    public int getCurrentPlayerCount()
-    {
+    public int getCurrentPlayerCount() {
         return this.playerList.getCurrentPlayerCount();
     }
 
-    public int getMaxPlayers()
-    {
+    public int getMaxPlayers() {
         return this.playerList.getMaxPlayers();
     }
 
-    public String[] getOnlinePlayerNames()
-    {
+    public String[] getOnlinePlayerNames() {
         return this.playerList.getOnlinePlayerNames();
     }
 
-    public GameProfile[] getOnlinePlayerProfiles()
-    {
+    public GameProfile[] getOnlinePlayerProfiles() {
         return this.playerList.getOnlinePlayerProfiles();
     }
 
-    public String getServerModName()
-    {
+    public String getServerModName() {
+        // TODO: Should we change this for CraftBukkit's server name?
         return net.minecraftforge.fml.common.FMLCommonHandler.instance().getModName();
     }
 
-    public CrashReport addServerInfoToCrashReport(CrashReport report)
-    {
-        report.getCategory().addDetail("Profiler Position", new ICrashReportDetail<String>()
-        {
-            public String call() throws Exception
-            {
-                return MinecraftServer.this.profiler.profilingEnabled ? MinecraftServer.this.profiler.getNameOfLastSection() : "N/A (disabled)";
+    public CrashReport addServerInfoToCrashReport(CrashReport report) {
+        report.getCategory().addDetail("Profiler Position", new ICrashReportDetail<String>() {
+            public String call() throws Exception {
+                return MinecraftServer.this.profiler.profilingEnabled
+                        ? MinecraftServer.this.profiler.getNameOfLastSection()
+                        : "N/A (disabled)";
             }
         });
 
-        if (this.playerList != null)
-        {
-            report.getCategory().addDetail("Player Count", new ICrashReportDetail<String>()
-            {
-                public String call()
-                {
-                    return MinecraftServer.this.playerList.getCurrentPlayerCount() + " / " + MinecraftServer.this.playerList.getMaxPlayers() + "; " + MinecraftServer.this.playerList.getPlayers();
+        if (this.playerList != null) {
+            report.getCategory().addDetail("Player Count", new ICrashReportDetail<String>() {
+                public String call() {
+                    return MinecraftServer.this.playerList.getCurrentPlayerCount() + " / "
+                            + MinecraftServer.this.playerList.getMaxPlayers() + "; "
+                            + MinecraftServer.this.playerList.getPlayers();
                 }
             });
         }
@@ -889,145 +1063,115 @@
         return report;
     }
 
-    public List<String> getTabCompletions(ICommandSender sender, String input, @Nullable BlockPos pos, boolean hasTargetBlock)
-    {
-        List<String> list = Lists.<String>newArrayList();
+    public List<String> getTabCompletions(ICommandSender sender, String input, @Nullable BlockPos pos,
+            boolean hasTargetBlock) {
+        Set<String> completionsSet = Sets.newHashSet(server.tabComplete(sender, input, pos, hasTargetBlock));
         boolean flag = input.startsWith("/");
 
-        if (flag)
-        {
+        if (flag) {
             input = input.substring(1);
         }
 
-        if (!flag && !hasTargetBlock)
-        {
+        if (!flag && !hasTargetBlock) {
             String[] astring = input.split(" ", -1);
             String s2 = astring[astring.length - 1];
 
-            for (String s1 : this.playerList.getOnlinePlayerNames())
-            {
-                if (CommandBase.doesStringStartWith(s2, s1))
-                {
-                    list.add(s1);
+            for (String s1 : this.playerList.getOnlinePlayerNames()) {
+                if (CommandBase.doesStringStartWith(s2, s1)) {
+                    completionsSet.add(s1);
                 }
             }
-
-            return list;
-        }
-        else
-        {
+        } else {
             boolean flag1 = !input.contains(" ");
             List<String> list1 = this.commandManager.getTabCompletions(sender, input, pos);
 
-            if (!list1.isEmpty())
-            {
-                for (String s : list1)
-                {
-                    if (flag1 && !hasTargetBlock)
-                    {
-                        list.add("/" + s);
+            if (!list1.isEmpty()) {
+                for (String s : list1) {
+                    if (flag1 && !hasTargetBlock) {
+                        completionsSet.add("/" + s);
+                    } else {
+                        completionsSet.add(s);
                     }
-                    else
-                    {
-                        list.add(s);
-                    }
                 }
             }
-
-            return list;
         }
+        List<String> finalCompletionsList = new ArrayList<>(completionsSet);
+        Collections.sort(finalCompletionsList);
+        return finalCompletionsList;
     }
 
-    public boolean isAnvilFileSet()
-    {
-        return this.anvilFile != null;
+    public boolean isAnvilFileSet() {
+        // return this.anvilFile != null;
+        return true; // CraftBukkit
     }
 
-    public String getName()
-    {
+    public String getName() {
         return "Server";
     }
 
-    public void sendMessage(ITextComponent component)
-    {
+    public void sendMessage(ITextComponent component) {
         LOGGER.info(component.getUnformattedText());
     }
 
-    public boolean canUseCommand(int permLevel, String commandName)
-    {
+    public boolean canUseCommand(int permLevel, String commandName) {
         return true;
     }
 
-    public ICommandManager getCommandManager()
+    public boolean canUseCommand(int permLevel, String commandName, String perm)
     {
+        return true;
+    }
+
+    public ICommandManager getCommandManager() {
         return this.commandManager;
     }
 
-    public KeyPair getKeyPair()
-    {
+    public KeyPair getKeyPair() {
         return this.serverKeyPair;
     }
 
-    public String getServerOwner()
-    {
+    public String getServerOwner() {
         return this.serverOwner;
     }
 
-    public void setServerOwner(String owner)
-    {
+    public void setServerOwner(String owner) {
         this.serverOwner = owner;
     }
 
-    public boolean isSinglePlayer()
-    {
+    public boolean isSinglePlayer() {
         return this.serverOwner != null;
     }
 
-    public String getFolderName()
-    {
+    public String getFolderName() {
         return this.folderName;
     }
 
-    public void setFolderName(String name)
-    {
+    public void setFolderName(String name) {
         this.folderName = name;
     }
 
-    @SideOnly(Side.CLIENT)
-    public void setWorldName(String worldNameIn)
-    {
+    public void setWorldName(String worldNameIn) {
         this.worldName = worldNameIn;
     }
 
-    @SideOnly(Side.CLIENT)
-    public String getWorldName()
-    {
+    public String getWorldName() {
         return this.worldName;
     }
 
-    public void setKeyPair(KeyPair keyPair)
-    {
+    public void setKeyPair(KeyPair keyPair) {
         this.serverKeyPair = keyPair;
     }
 
-    public void setDifficultyForAllWorlds(EnumDifficulty difficulty)
-    {
-        for (WorldServer worldserver1 : this.worlds)
-        {
-            if (worldserver1 != null)
-            {
-                if (worldserver1.getWorldInfo().isHardcoreModeEnabled())
-                {
+    public void setDifficultyForAllWorlds(EnumDifficulty difficulty) {
+        for (WorldServer worldserver1 : this.worldServerList) {
+            if (worldserver1 != null) {
+                if (worldserver1.getWorldInfo().isHardcoreModeEnabled()) {
                     worldserver1.getWorldInfo().setDifficulty(EnumDifficulty.HARD);
                     worldserver1.setAllowedSpawnTypes(true, true);
-                }
-                else if (this.isSinglePlayer())
-                {
+                } else if (this.isSinglePlayer()) {
                     worldserver1.getWorldInfo().setDifficulty(difficulty);
                     worldserver1.setAllowedSpawnTypes(worldserver1.getDifficulty() != EnumDifficulty.PEACEFUL, true);
-                }
-                else
-                {
+                } else {
                     worldserver1.getWorldInfo().setDifficulty(difficulty);
                     worldserver1.setAllowedSpawnTypes(this.allowSpawnMonsters(), this.canSpawnAnimals);
                 }
@@ -1035,80 +1179,75 @@
         }
     }
 
-    public boolean allowSpawnMonsters()
-    {
+    public boolean allowSpawnMonsters() {
         return true;
     }
 
-    public boolean isDemo()
-    {
+    public boolean isDemo() {
         return this.isDemo;
     }
 
-    public void setDemo(boolean demo)
-    {
+    public void setDemo(boolean demo) {
         this.isDemo = demo;
     }
 
-    public void canCreateBonusChest(boolean enable)
-    {
+    public void canCreateBonusChest(boolean enable) {
         this.enableBonusChest = enable;
     }
 
-    public ISaveFormat getActiveAnvilConverter()
-    {
+    public ISaveFormat getActiveAnvilConverter() {
         return this.anvilConverterForAnvilFile;
     }
 
-    public String getResourcePackUrl()
-    {
+    public String getResourcePackUrl() {
         return this.resourcePackUrl;
     }
 
-    public String getResourcePackHash()
-    {
+    public String getResourcePackHash() {
         return this.resourcePackHash;
     }
 
-    public void setResourcePack(String url, String hash)
-    {
+    public void setResourcePack(String url, String hash) {
         this.resourcePackUrl = url;
         this.resourcePackHash = hash;
     }
 
-    public void addServerStatsToSnooper(Snooper playerSnooper)
-    {
+    public void addServerStatsToSnooper(Snooper playerSnooper) {
         playerSnooper.addClientStat("whitelist_enabled", Boolean.valueOf(false));
         playerSnooper.addClientStat("whitelist_count", Integer.valueOf(0));
 
-        if (this.playerList != null)
-        {
+        if (this.playerList != null) {
             playerSnooper.addClientStat("players_current", Integer.valueOf(this.getCurrentPlayerCount()));
             playerSnooper.addClientStat("players_max", Integer.valueOf(this.getMaxPlayers()));
-            playerSnooper.addClientStat("players_seen", Integer.valueOf(this.playerList.getAvailablePlayerDat().length));
+            playerSnooper.addClientStat("players_seen",
+                    Integer.valueOf(this.playerList.getAvailablePlayerDat().length));
         }
 
         playerSnooper.addClientStat("uses_auth", Boolean.valueOf(this.onlineMode));
         playerSnooper.addClientStat("gui_state", this.getGuiEnabled() ? "enabled" : "disabled");
-        playerSnooper.addClientStat("run_time", Long.valueOf((getCurrentTimeMillis() - playerSnooper.getMinecraftStartTimeMillis()) / 60L * 1000L));
-        playerSnooper.addClientStat("avg_tick_ms", Integer.valueOf((int)(MathHelper.average(this.tickTimeArray) * 1.0E-6D)));
+        playerSnooper.addClientStat("run_time",
+                Long.valueOf((getCurrentTimeMillis() - playerSnooper.getMinecraftStartTimeMillis()) / 60L * 1000L));
+        playerSnooper.addClientStat("avg_tick_ms",
+                Integer.valueOf((int) (MathHelper.average(this.tickTimeArray) * 1.0E-6D)));
         int l = 0;
 
-        if (this.worlds != null)
-        {
-            for (WorldServer worldserver1 : this.worlds)
-            {
-                if (worldserver1 != null)
-                {
+        if (this.worldServerList != null) {
+            for (WorldServer worldserver1 : this.worldServerList) {
+                if (worldserver1 != null) {
                     WorldInfo worldinfo = worldserver1.getWorldInfo();
-                    playerSnooper.addClientStat("world[" + l + "][dimension]", Integer.valueOf(worldserver1.provider.getDimensionType().getId()));
+                    playerSnooper.addClientStat("world[" + l + "][dimension]",
+                            Integer.valueOf(worldserver1.provider.getDimensionType().getId()));
                     playerSnooper.addClientStat("world[" + l + "][mode]", worldinfo.getGameType());
                     playerSnooper.addClientStat("world[" + l + "][difficulty]", worldserver1.getDifficulty());
-                    playerSnooper.addClientStat("world[" + l + "][hardcore]", Boolean.valueOf(worldinfo.isHardcoreModeEnabled()));
-                    playerSnooper.addClientStat("world[" + l + "][generator_name]", worldinfo.getTerrainType().getName());
-                    playerSnooper.addClientStat("world[" + l + "][generator_version]", Integer.valueOf(worldinfo.getTerrainType().getVersion()));
+                    playerSnooper.addClientStat("world[" + l + "][hardcore]",
+                            Boolean.valueOf(worldinfo.isHardcoreModeEnabled()));
+                    playerSnooper.addClientStat("world[" + l + "][generator_name]",
+                            worldinfo.getTerrainType().getName());
+                    playerSnooper.addClientStat("world[" + l + "][generator_version]",
+                            Integer.valueOf(worldinfo.getTerrainType().getVersion()));
                     playerSnooper.addClientStat("world[" + l + "][height]", Integer.valueOf(this.buildLimit));
-                    playerSnooper.addClientStat("world[" + l + "][chunks_loaded]", Integer.valueOf(worldserver1.getChunkProvider().getLoadedChunkCount()));
+                    playerSnooper.addClientStat("world[" + l + "][chunks_loaded]",
+                            Integer.valueOf(worldserver1.getChunkProvider().getLoadedChunkCount()));
                     ++l;
                 }
             }
@@ -1117,228 +1256,186 @@
         playerSnooper.addClientStat("worlds", Integer.valueOf(l));
     }
 
-    public void addServerTypeToSnooper(Snooper playerSnooper)
-    {
+    public void addServerTypeToSnooper(Snooper playerSnooper) {
         playerSnooper.addStatToSnooper("singleplayer", Boolean.valueOf(this.isSinglePlayer()));
         playerSnooper.addStatToSnooper("server_brand", this.getServerModName());
         playerSnooper.addStatToSnooper("gui_supported", GraphicsEnvironment.isHeadless() ? "headless" : "supported");
         playerSnooper.addStatToSnooper("dedicated", Boolean.valueOf(this.isDedicatedServer()));
     }
 
-    public boolean isSnooperEnabled()
-    {
+    public boolean isSnooperEnabled() {
         return true;
     }
 
     public abstract boolean isDedicatedServer();
 
-    public boolean isServerInOnlineMode()
-    {
-        return this.onlineMode;
+    public boolean isServerInOnlineMode() {
+        // return this.onlineMode;
+        return server.getOnlineMode(); // CraftBukkit
     }
 
-    public void setOnlineMode(boolean online)
-    {
+    public void setOnlineMode(boolean online) {
         this.onlineMode = online;
     }
 
-    public boolean getPreventProxyConnections()
-    {
+    public boolean getPreventProxyConnections() {
         return this.preventProxyConnections;
     }
 
-    public boolean getCanSpawnAnimals()
-    {
+    public boolean getCanSpawnAnimals() {
         return this.canSpawnAnimals;
     }
 
-    public void setCanSpawnAnimals(boolean spawnAnimals)
-    {
+    public void setCanSpawnAnimals(boolean spawnAnimals) {
         this.canSpawnAnimals = spawnAnimals;
     }
 
-    public boolean getCanSpawnNPCs()
-    {
+    public boolean getCanSpawnNPCs() {
         return this.canSpawnNPCs;
     }
 
     public abstract boolean shouldUseNativeTransport();
 
-    public void setCanSpawnNPCs(boolean spawnNpcs)
-    {
+    public void setCanSpawnNPCs(boolean spawnNpcs) {
         this.canSpawnNPCs = spawnNpcs;
     }
 
-    public boolean isPVPEnabled()
-    {
+    public boolean isPVPEnabled() {
         return this.pvpEnabled;
     }
 
-    public void setAllowPvp(boolean allowPvp)
-    {
+    public void setAllowPvp(boolean allowPvp) {
         this.pvpEnabled = allowPvp;
     }
 
-    public boolean isFlightAllowed()
-    {
+    public boolean isFlightAllowed() {
         return this.allowFlight;
     }
 
-    public void setAllowFlight(boolean allow)
-    {
+    public void setAllowFlight(boolean allow) {
         this.allowFlight = allow;
     }
 
     public abstract boolean isCommandBlockEnabled();
 
-    public String getMOTD()
-    {
+    public String getMOTD() {
         return this.motd;
     }
 
-    public void setMOTD(String motdIn)
-    {
+    public void setMOTD(String motdIn) {
         this.motd = motdIn;
     }
 
-    public int getBuildLimit()
-    {
+    public int getBuildLimit() {
         return this.buildLimit;
     }
 
-    public void setBuildLimit(int maxBuildHeight)
-    {
+    public void setBuildLimit(int maxBuildHeight) {
         this.buildLimit = maxBuildHeight;
     }
 
-    public boolean isServerStopped()
-    {
+    public boolean isServerStopped() {
         return this.serverStopped;
     }
 
-    public PlayerList getPlayerList()
-    {
+    public PlayerList getPlayerList() {
         return this.playerList;
     }
 
-    public void setPlayerList(PlayerList list)
-    {
+    public void setPlayerList(PlayerList list) {
         this.playerList = list;
     }
 
-    public void setGameType(GameType gameMode)
-    {
-        for (WorldServer worldserver1 : this.worlds)
-        {
+    public void setGameType(GameType gameMode) {
+        for (WorldServer worldserver1 : this.worldServerList) {
             worldserver1.getWorldInfo().setGameType(gameMode);
         }
     }
 
-    public NetworkSystem getNetworkSystem()
-    {
+    public NetworkSystem getNetworkSystem() {
         return this.networkSystem;
     }
 
     @SideOnly(Side.CLIENT)
-    public boolean serverIsInRunLoop()
-    {
+    public boolean serverIsInRunLoop() {
         return this.serverIsRunning;
     }
 
-    public boolean getGuiEnabled()
-    {
+    public boolean getGuiEnabled() {
         return false;
     }
 
     public abstract String shareToLAN(GameType type, boolean allowCheats);
 
-    public int getTickCounter()
-    {
+    public int getTickCounter() {
         return this.tickCounter;
     }
 
-    public void enableProfiling()
-    {
+    public void enableProfiling() {
         this.startProfiling = true;
     }
 
     @SideOnly(Side.CLIENT)
-    public Snooper getPlayerUsageSnooper()
-    {
+    public Snooper getPlayerUsageSnooper() {
         return this.usageSnooper;
     }
 
-    public World getEntityWorld()
-    {
-        return this.worlds[0];
+    public World getEntityWorld() {
+        // return this.worlds[0];
+        return this.worlds[0]; // CraftBukkit
     }
 
-    public boolean isBlockProtected(World worldIn, BlockPos pos, EntityPlayer playerIn)
-    {
+    public boolean isBlockProtected(World worldIn, BlockPos pos, EntityPlayer playerIn) {
         return false;
     }
 
-    public boolean getForceGamemode()
-    {
+    public boolean getForceGamemode() {
         return this.isGamemodeForced;
     }
 
-    public Proxy getServerProxy()
-    {
+    public Proxy getServerProxy() {
         return this.serverProxy;
     }
 
-    public static long getCurrentTimeMillis()
-    {
+    public static long getCurrentTimeMillis() {
         return System.currentTimeMillis();
     }
 
-    public int getMaxPlayerIdleMinutes()
-    {
+    public int getMaxPlayerIdleMinutes() {
         return this.maxPlayerIdleMinutes;
     }
 
-    public void setPlayerIdleTimeout(int idleTimeout)
-    {
+    public void setPlayerIdleTimeout(int idleTimeout) {
         this.maxPlayerIdleMinutes = idleTimeout;
     }
 
-    public MinecraftSessionService getMinecraftSessionService()
-    {
+    public MinecraftSessionService getMinecraftSessionService() {
         return this.sessionService;
     }
 
-    public GameProfileRepository getGameProfileRepository()
-    {
+    public GameProfileRepository getGameProfileRepository() {
         return this.profileRepo;
     }
 
-    public PlayerProfileCache getPlayerProfileCache()
-    {
+    public PlayerProfileCache getPlayerProfileCache() {
         return this.profileCache;
     }
 
-    public ServerStatusResponse getServerStatusResponse()
-    {
+    public ServerStatusResponse getServerStatusResponse() {
         return this.statusResponse;
     }
 
-    public void refreshStatusNextTick()
-    {
+    public void refreshStatusNextTick() {
         this.nanoTimeSinceStatusRefresh = 0L;
     }
 
     @Nullable
-    public Entity getEntityFromUuid(UUID uuid)
-    {
-        for (WorldServer worldserver1 : this.worlds)
-        {
-            if (worldserver1 != null)
-            {
+    public Entity getEntityFromUuid(UUID uuid) {
+        for (WorldServer worldserver1 : this.worldServerList) {
+            if (worldserver1 != null) {
                 Entity entity = worldserver1.getEntityFromUuid(uuid);
 
-                if (entity != null)
-                {
+                if (entity != null) {
                     return entity;
                 }
             }
@@ -1347,130 +1444,120 @@
         return null;
     }
 
-    public boolean sendCommandFeedback()
-    {
-        return this.worlds[0].getGameRules().getBoolean("sendCommandFeedback");
+    public boolean sendCommandFeedback() {
+        // return this.worlds[0].getGameRules().getBoolean("sendCommandFeedback");
+        return worlds[0].getGameRules().getBoolean("sendCommandFeedback");
     }
 
-    public MinecraftServer getServer()
-    {
+    public MinecraftServer getServer() {
         return this;
     }
 
-    public int getMaxWorldSize()
-    {
+    public static MinecraftServer getServerInstance() {
+         return instance;
+    }
+
+    @Nullable
+    @Deprecated
+    public static MinecraftServer getServerCB() {
+        return (Bukkit.getServer() instanceof CraftServer) ? ((CraftServer) Bukkit.getServer()).getServer() : null;
+    }
+
+    public int getMaxWorldSize() {
         return 29999984;
     }
 
-    public <V> ListenableFuture<V> callFromMainThread(Callable<V> callable)
-    {
+    public <V> ListenableFuture<V> callFromMainThread(Callable<V> callable) {
         Validate.notNull(callable);
 
-        if (!this.isCallingFromMinecraftThread() && !this.isServerStopped())
+        if (!this.isCallingFromMinecraftThread()/* && !this.isServerStopped()*/) // CraftBukkit
         {
             ListenableFutureTask<V> listenablefuturetask = ListenableFutureTask.<V>create(callable);
 
-            synchronized (this.futureTaskQueue)
-            {
+            synchronized (this.futureTaskQueue) {
                 this.futureTaskQueue.add(listenablefuturetask);
                 return listenablefuturetask;
             }
-        }
-        else
-        {
-            try
-            {
+        } else {
+            try {
                 return Futures.<V>immediateFuture(callable.call());
-            }
-            catch (Exception exception)
-            {
+            } catch (Exception exception) {
                 return Futures.immediateFailedCheckedFuture(exception);
             }
         }
     }
 
-    public ListenableFuture<Object> addScheduledTask(Runnable runnableToSchedule)
-    {
+    public ListenableFuture<Object> addScheduledTask(Runnable runnableToSchedule) {
         Validate.notNull(runnableToSchedule);
         return this.<Object>callFromMainThread(Executors.callable(runnableToSchedule));
     }
 
-    public boolean isCallingFromMinecraftThread()
-    {
+    public boolean isCallingFromMinecraftThread() {
         return Thread.currentThread() == this.serverThread;
     }
 
-    public int getNetworkCompressionThreshold()
-    {
+    public int getNetworkCompressionThreshold() {
         return 256;
     }
 
-    public int getSpawnRadius(@Nullable WorldServer worldIn)
-    {
+    public int getSpawnRadius(@Nullable WorldServer worldIn) {
         return worldIn != null ? worldIn.getGameRules().getInt("spawnRadius") : 10;
     }
 
-    public AdvancementManager getAdvancementManager()
-    {
+    public AdvancementManager getAdvancementManager() {
+        // return this.worlds[0].getAdvancementManager();
         return this.worlds[0].getAdvancementManager();
     }
 
-    public FunctionManager getFunctionManager()
-    {
+    public FunctionManager getFunctionManager() {
+        // return this.worlds[0].getFunctionManager();
         return this.worlds[0].getFunctionManager();
     }
 
-    public void reload()
-    {
-        if (this.isCallingFromMinecraftThread())
-        {
+    public void reload() {
+        if (this.isCallingFromMinecraftThread()) {
             this.getPlayerList().saveAllPlayerData();
+            // this.worlds[0].getLootTableManager().reloadLootTables();
             this.worlds[0].getLootTableManager().reloadLootTables();
             this.getAdvancementManager().reload();
             this.getFunctionManager().reload();
             this.getPlayerList().reloadResources();
-        }
-        else
-        {
+        } else {
             this.addScheduledTask(this::reload);
         }
     }
 
     @SideOnly(Side.SERVER)
-    public String getServerHostname()
-    {
+    public String getServerHostname() {
         return this.hostname;
     }
 
     @SideOnly(Side.SERVER)
-    public void setHostname(String host)
-    {
+    public void setHostname(String host) {
         this.hostname = host;
     }
 
     @SideOnly(Side.SERVER)
-    public void registerTickable(ITickable tickable)
-    {
+    public void registerTickable(ITickable tickable) {
         this.tickables.add(tickable);
     }
 
     @SideOnly(Side.SERVER)
-    public static void main(String[] p_main_0_)
-    {
+    public static void main(String[] args) {
+        OptionSet options = org.bukkit.craftbukkit.Main.main(args);
+        if (options == null)
+            return;
         //Forge: Copied from DedicatedServer.init as to run as early as possible, Old code left in place intentionally.
         //Done in good faith with permission: https://github.com/MinecraftForge/MinecraftForge/issues/3659#issuecomment-390467028
         ServerEula eula = new ServerEula(new File("eula.txt"));
-        if (!eula.hasAcceptedEULA())
-        {
+        if (!eula.hasAcceptedEULA()) {
             LOGGER.info("You need to agree to the EULA in order to run the server. Go to eula.txt for more info.");
             eula.createEULAFile();
             return;
         }
-
         Bootstrap.register();
-
-        try
-        {
+        try {
+            /* CraftBukkit start - Replace everything
             boolean flag = true;
             String s = null;
             String s1 = ".";
@@ -1534,13 +1621,19 @@
                     ++i1;
                 }
             }
-
-            YggdrasilAuthenticationService yggdrasilauthenticationservice = new YggdrasilAuthenticationService(Proxy.NO_PROXY, UUID.randomUUID().toString());
-            MinecraftSessionService minecraftsessionservice = yggdrasilauthenticationservice.createMinecraftSessionService();
+            */ // CraftBukkit end
+            String s1 = ".";
+            YggdrasilAuthenticationService yggdrasilauthenticationservice = new YggdrasilAuthenticationService(
+                    Proxy.NO_PROXY, UUID.randomUUID().toString());
+            MinecraftSessionService minecraftsessionservice = yggdrasilauthenticationservice
+                    .createMinecraftSessionService();
             GameProfileRepository gameprofilerepository = yggdrasilauthenticationservice.createProfileRepository();
-            PlayerProfileCache playerprofilecache = new PlayerProfileCache(gameprofilerepository, new File(s1, USER_CACHE_FILE.getName()));
-            final DedicatedServer dedicatedserver = new DedicatedServer(new File(s1), DataFixesManager.createFixer(), yggdrasilauthenticationservice, minecraftsessionservice, gameprofilerepository, playerprofilecache);
+            PlayerProfileCache playerprofilecache = new PlayerProfileCache(gameprofilerepository,
+                    new File(s1, USER_CACHE_FILE.getName()));
+            final DedicatedServer dedicatedserver = new DedicatedServer(options, DataFixesManager.createFixer(),
+                    yggdrasilauthenticationservice, minecraftsessionservice, gameprofilerepository, playerprofilecache);
 
+            /* CraftBukkit start
             if (s != null)
             {
                 dedicatedserver.setServerOwner(s);
@@ -1579,84 +1672,87 @@
                     dedicatedserver.stopServer();
                 }
             });
+            */
+            if (options.has("port")) {
+                int port = (Integer) options.valueOf("port");
+                if (port > 0) {
+                    dedicatedserver.setServerPort(port);
+                }
+            }
+
+            if (options.has("universe")) {
+                dedicatedserver.anvilFile = (File) options.valueOf("universe");
+            }
+
+            if (options.has("world")) {
+                dedicatedserver.setWorldName((String) options.valueOf("world"));
+            }
+
+            dedicatedserver.primaryThread.start();
+        } catch (Exception exception) {
+            LOGGER.fatal("Failed to start the minecraft server", (Throwable) exception);
         }
-        catch (Exception exception)
-        {
-            LOGGER.fatal("Failed to start the minecraft server", (Throwable)exception);
-        }
     }
 
     @SideOnly(Side.SERVER)
-    public void logInfo(String msg)
-    {
+    public void logInfo(String msg) {
         LOGGER.info(msg);
     }
 
     @SideOnly(Side.SERVER)
-    public boolean isDebuggingEnabled()
-    {
-        return false;
+    public boolean isDebuggingEnabled() {
+        // return false;
+        return this.getPropertyManager().getBooleanProperty("debug", false); // CraftBukkit - don't hardcode
     }
 
     @SideOnly(Side.SERVER)
-    public void logSevere(String msg)
-    {
+    public void logSevere(String msg) {
         LOGGER.error(msg);
     }
 
     @SideOnly(Side.SERVER)
-    public void logDebug(String msg)
-    {
-        if (this.isDebuggingEnabled())
-        {
+    public void logDebug(String msg) {
+        if (this.isDebuggingEnabled()) {
             LOGGER.info(msg);
         }
     }
 
     @SideOnly(Side.SERVER)
-    public int getServerPort()
-    {
+    public int getServerPort() {
         return this.serverPort;
     }
 
     @SideOnly(Side.SERVER)
-    public void setServerPort(int port)
-    {
+    public void setServerPort(int port) {
         this.serverPort = port;
     }
 
     @SideOnly(Side.SERVER)
-    public void setPreventProxyConnections(boolean p_190517_1_)
-    {
+    public void setPreventProxyConnections(boolean p_190517_1_) {
         this.preventProxyConnections = p_190517_1_;
     }
 
     @SideOnly(Side.SERVER)
-    public int getSpawnProtectionSize()
-    {
+    public int getSpawnProtectionSize() {
         return 16;
     }
 
     @SideOnly(Side.SERVER)
-    public void setForceGamemode(boolean force)
-    {
+    public void setForceGamemode(boolean force) {
         this.isGamemodeForced = force;
     }
 
     @SideOnly(Side.SERVER)
-    public long getCurrentTime()
-    {
+    public long getCurrentTime() {
         return this.currentTime;
     }
 
     @SideOnly(Side.SERVER)
-    public Thread getServerThread()
-    {
+    public Thread getServerThread() {
         return this.serverThread;
     }
 
-    public DataFixer getDataFixer()
-    {
+    public DataFixer getDataFixer() {
         return this.dataFixer;
     }
 }
